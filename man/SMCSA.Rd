% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SA-based.R
\name{SMCSA}
\alias{SMCSA}
\title{SMC-SA}
\usage{
SMCSA(objf, proposal, starting, schedule, N = 1000, iter = 100,
  diagnostic = FALSE, verbose = FALSE)
}
\arguments{
\item{objf}{an objective function that takes a matrix with each column
corresponds to a state, and return a vector with respective objective
function values. (num mat -> num vec)}

\item{proposal}{a random walk proposal that takes a matrix, and produces a
matrix of proposed states, centred on the corresponding columns of the
input matrix. It should also take in the current iteration count. ((num
mat, num) -> num mat)}

\item{starting}{a matrix with each column corresponding to a starting
state. This code assumes that the starting values are feasible. (num mat)}

\item{schedule}{a cooling schedule, taking the current iteration count and
the absolute value of the current lowest objective function value as its
first and second arguments respectively, and return a temperature. (num,
num -> num)}

\item{N}{the number of initial states. If this number is greater than the
column size of \code{starting}, \code{starting} will be recycled. (num)}

\item{iter}{total number of iterations. (num)}

\item{diagnostic}{print out diagnostic plots? (bool)}

\item{verbose}{show the algorithm progression? (bool)}
}
\value{
a list that contains the best state, its objective function
    value, and the acceptance rate at each iteration.
}
\description{
Minimise an objective function using SMC-SA with supplied starting states, a
proposal distribution and a cooling schedule.
}
\details{
The constraints are enforced by using an appropriate proposal
distribution. It is advisable that the proposal variance is decreased after
each iteration (hence the reason the proposal distribution should take the
current iteration count in addition to the current state). The iterator in
this code starts from 1 to N.

Diagnostic plots include a boxplot of the objective function
values and a scatterplot of the acceptance probabilities, both of which are
plotted for each iteration. The supplied starting values are recycled to
construct \code{N} starting values.
}
